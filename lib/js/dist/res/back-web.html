<script>
// MULTIPLE CHOICE BACK TEMPLATE v1.3 {{{
// https://gist.github.com/hgiesel/2e8361afccca5713414a6a4ee66b7ece
if (window.Persistence && Persistence.isAvailable() && Persistence.getItem("multipleChoiceSettings")) {
    var settings = Persistence.getItem("multipleChoiceSettings")

    var query = settings.query
    var colors = settings.colors
    var fieldPadding = settings.fieldPadding

    var syntax = {
        openDelim: settings.syntax.openDelim,
        closeDelim: settings.syntax.closeDelim,
        fieldSeparator: settings.syntax.fieldSeparator,
    }
    var output = {
        openDelim: settings.output.openDelim,
        closeDelim: settings.output.closeDelim,
        fieldSeparator: settings.output.fieldSeparator,
    }

    ////
    function escapeString(str) {
        return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    var exprRegex = RegExp(`(?:${escapeString(syntax.openDelim)})(.*?)(?:${escapeString(syntax.closeDelim)})`, 'gm')
    var refRegex  = /^\^\d+$/
    var drawRegex = /^\^\d+\+\d+/

    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex
        // While there remain elements to shuffle...
        while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex   = Math.floor(Math.random() * currentIndex)
            currentIndex -= 1
            // And swap it with the current element.
            temporaryValue      = array[currentIndex]
            array[currentIndex] = array[randomIndex]
            array[randomIndex]  = temporaryValue
        }
        return array;
    }

    var results = []
    var theBody = document.querySelector(query).innerHTML

    var m = exprRegex.exec(theBody)

    while (m) {
        results.push(m[1])
        m = exprRegex.exec(theBody)
    }

    if (results.length > 0) {
        var alteredResults = []

        //// PROCESSING OF BACK CARD
        if (window.Persistence && Persistence.isAvailable() && Persistence.getItem("multipleChoiceData")) {
            alteredResults = Persistence.getItem("multipleChoiceData")

            var splitResults = []
            for ([i, group] of results.entries()) {
                splitResults.push(group.split(syntax.fieldSeparator).map((v, j) => [i, j, v, true]))
            }

            for ([i, group] of alteredResults.entries()) {
                for ([j, field] of group.entries()) {
                    if (field[2].includes('class="cloze"')) {
                        var visibilitySave = alteredResults[i][j][3]
                        alteredResults[i][j] = [...splitResults[field[0]][field[1]]]
                        alteredResults[i][j][3] = visibilitySave
                    }
                }
            }

            var stylizedAlteredResults = []
            for (group of alteredResults) {

                var actualvaluesalter = []
                for ([i, field] of group.entries()) {
                    if (field[3]) {
                        var theIndex = i % colors.length
                        actualvaluesalter.push(`<span style="color: ${colors[theIndex]}; padding: 0px ${fieldPadding};">${field[2]}</span>`)
                    }
                }

                stylizedAlteredResults.push(actualvaluesalter.join(output.fieldSeparator))
            }

            for ([i, v] of results.entries()) {
                var replacement = document.querySelector(query).innerHTML
                    .replace(`${syntax.openDelim}${v}${syntax.closeDelim}`, `${output.openDelim}${stylizedAlteredResults[i]}${output.closeDelim}`)
                document.querySelector(query).innerHTML = replacement
            }

            // for ClozeOverlapper
            if (query === "div#clozed") {
                var results = []
                var theBody = document.getElementById('original').innerHTML

                var m = exprRegex.exec(theBody)

                while (m) {
                    results.push(m[1])
                    m = exprRegex.exec(theBody)
                }

                var innerSplitResults = []
                for ([i, group] of results.entries()) {
                    innerSplitResults.push(group.split(syntax.fieldSeparator).map((v, j) => [i, j, v, true]))
                }

                var origResults = []
                for ([i, group] of innerSplitResults.entries()) {

                    var newGroup = []
                    for ([j, field] of group.entries()) {

                        if (refRegex.test(field[2])) {
                            var refGroup = field[2].match(/\d+/)[0]
                            for (elem of origResults[refGroup]) {
                                newGroup.push([...elem])
                            }
                        }

                        else if (drawRegex.test(field[2])) {
                            var match      = field[2].match(/^\^(\d+)\+(\d+)$/)
                            var drawGroup  = match[1]
                            var drawAmount = match[2]

                            for (i = 0; i < drawAmount; i++) {
                                var lastElemIndex = [...origResults[drawGroup]].reverse().findIndex(v => v[3])
                                if (lastElemIndex != -1) {
                                    var actualIndex = origResults[drawGroup].length - lastElemIndex - 1
                                    newGroup.push([...origResults[drawGroup][actualIndex]])

                                    // set visibility to false
                                    origResults[drawGroup][actualIndex][3] = false
                                }
                            }
                        }

                        else {
                            var iIndex = alteredResults[i][j][0]
                            var jIndex = alteredResults[i][j][1]
                            var newContent = innerSplitResults[iIndex][jIndex][2]

                            newGroup.push([iIndex, jIndex, newContent, true])
                        }
                    }

                    origResults.push(newGroup)
                }

                var stylizedOrigResults = []
                for (group of origResults) {
                    var actualvaluesorig = []
                    for ([i, field] of group.entries()) {
                        if (field[3]) {
                            var theIndex = i % colors.length
                            actualvaluesorig.push(`<span style="color: ${colors[theIndex]}; padding: 0px ${fieldPadding};">${field[2]}</span>`)
                        }
                    }

                    stylizedOrigResults.push(actualvaluesorig.join(output.fieldSeparator))
                }

                for ([i, v] of results.entries()) {
                    var replacementorig = document.getElementById('original').innerHTML
                        .replace(`${syntax.openDelim}${v}${syntax.closeDelim}`, `${output.openDelim}${stylizedOrigResults[i]}${output.closeDelim}`)
                    document.getElementById('original').innerHTML = replacementorig
                }
            }

        }

        if (window.Persistence && Persistence.isAvailable()) {
            Persistence.removeItem("multipleChoiceData")
            Persistence.removeItem("multipleChoiceSettings")
        }
    }
}
// MULTIPLE CHOICE BACK TEMPLATE v1.3 }}}
</script>
